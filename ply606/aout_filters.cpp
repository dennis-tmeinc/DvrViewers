#include "stdafx.h"
#include <crtdbg.h>
#include <errno.h>
#include "audio_output.h"
#include "aout_internal.h"

/* Conversion constants */
#define Nhc       8
#define Npc      (1<<Nhc)

#define SMALL_FILTER_NMULT ((INT16)13)
#define SMALL_FILTER_SCALE 13128 /* Unity-gain scale factor */
#define SMALL_FILTER_NWING 1536 /* Filter table length */

static float SMALL_FILTER_FLOAT_IMP[] /* Impulse response */ = {
0.900000f,
0.899980f,
0.899920f,
0.899821f,
0.899681f,
0.899502f,
0.899283f,
0.899024f,
0.898726f,
0.898388f,
0.898010f,
0.897592f,
0.897135f,
0.896638f,
0.896102f,
0.895526f,
0.894911f,
0.894256f,
0.893562f,
0.892829f,
0.892056f,
0.891244f,
0.890394f,
0.889504f,
0.888575f,
0.887608f,
0.886602f,
0.885557f,
0.884474f,
0.883352f,
0.882192f,
0.880993f,
0.879756f,
0.878482f,
0.877169f,
0.875818f,
0.874430f,
0.873004f,
0.871541f,
0.870040f,
0.868502f,
0.866927f,
0.865315f,
0.863667f,
0.861981f,
0.860259f,
0.858501f,
0.856707f,
0.854876f,
0.853010f,
0.851108f,
0.849170f,
0.847197f,
0.845189f,
0.843146f,
0.841067f,
0.838954f,
0.836807f,
0.834625f,
0.832409f,
0.830160f,
0.827876f,
0.825559f,
0.823209f,
0.820825f,
0.818408f,
0.815959f,
0.813477f,
0.810963f,
0.808417f,
0.805839f,
0.803229f,
0.800588f,
0.797916f,
0.795213f,
0.792479f,
0.789714f,
0.786919f,
0.784095f,
0.781240f,
0.778356f,
0.775442f,
0.772500f,
0.769529f,
0.766529f,
0.763501f,
0.760444f,
0.757361f,
0.754249f,
0.751110f,
0.747945f,
0.744753f,
0.741534f,
0.738289f,
0.735018f,
0.731721f,
0.728400f,
0.725053f,
0.721681f,
0.718285f,
0.714865f,
0.711420f,
0.707953f,
0.704461f,
0.700947f,
0.697410f,
0.693851f,
0.690269f,
0.686665f,
0.683040f,
0.679394f,
0.675727f,
0.672039f,
0.668331f,
0.664602f,
0.660854f,
0.657087f,
0.653300f,
0.649495f,
0.645671f,
0.641829f,
0.637969f,
0.634091f,
0.630197f,
0.626285f,
0.622357f,
0.618412f,
0.614452f,
0.610476f,
0.606485f,
0.602478f,
0.598457f,
0.594422f,
0.590373f,
0.586310f,
0.582234f,
0.578144f,
0.574042f,
0.569928f,
0.565801f,
0.561663f,
0.557514f,
0.553353f,
0.549182f,
0.545001f,
0.540809f,
0.536607f,
0.532397f,
0.528177f,
0.523948f,
0.519711f,
0.515466f,
0.511214f,
0.506954f,
0.502686f,
0.498413f,
0.494132f,
0.489846f,
0.485554f,
0.481256f,
0.476954f,
0.472646f,
0.468335f,
0.464019f,
0.459699f,
0.455377f,
0.451050f,
0.446722f,
0.442390f,
0.438057f,
0.433722f,
0.429385f,
0.425048f,
0.420709f,
0.416370f,
0.412031f,
0.407692f,
0.403354f,
0.399016f,
0.394679f,
0.390344f,
0.386011f,
0.381680f,
0.377351f,
0.373025f,
0.368702f,
0.364382f,
0.360066f,
0.355754f,
0.351446f,
0.347143f,
0.342844f,
0.338551f,
0.334264f,
0.329982f,
0.325706f,
0.321437f,
0.317174f,
0.312918f,
0.308670f,
0.304429f,
0.300197f,
0.295972f,
0.291756f,
0.287548f,
0.283350f,
0.279161f,
0.274982f,
0.270812f,
0.266653f,
0.262504f,
0.258366f,
0.254239f,
0.250123f,
0.246018f,
0.241926f,
0.237846f,
0.233777f,
0.229722f,
0.225679f,
0.221650f,
0.217634f,
0.213632f,
0.209643f,
0.205669f,
0.201709f,
0.197764f,
0.193833f,
0.189918f,
0.186018f,
0.182134f,
0.178265f,
0.174413f,
0.170577f,
0.166758f,
0.162955f,
0.159169f,
0.155401f,
0.151650f,
0.147916f,
0.144201f,
0.140503f,
0.136824f,
0.133163f,
0.129521f,
0.125898f,
0.122294f,
0.118710f,
0.115145f,
0.111599f,
0.108073f,
0.104568f,
0.101083f,
0.097618f,
0.094174f,
0.090750f,
0.087348f,
0.083966f,
0.080606f,
0.077268f,
0.073951f,
0.070656f,
0.067383f,
0.064132f,
0.060903f,
0.057697f,
0.054513f,
0.051352f,
0.048214f,
0.045099f,
0.042006f,
0.038938f,
0.035892f,
0.032870f,
0.029872f,
0.026898f,
0.023947f,
0.021021f,
0.018118f,
0.015240f,
0.012386f,
0.009557f,
0.006752f,
0.003972f,
0.001217f,
-0.001514f,
-0.004219f,
-0.006900f,
-0.009555f,
-0.012186f,
-0.014790f,
-0.017370f,
-0.019924f,
-0.022453f,
-0.024956f,
-0.027433f,
-0.029885f,
-0.032310f,
-0.034710f,
-0.037085f,
-0.039433f,
-0.041755f,
-0.044051f,
-0.046321f,
-0.048565f,
-0.050782f,
-0.052974f,
-0.055139f,
-0.057278f,
-0.059391f,
-0.061477f,
-0.063537f,
-0.065570f,
-0.067577f,
-0.069558f,
-0.071513f,
-0.073440f,
-0.075342f,
-0.077217f,
-0.079065f,
-0.080887f,
-0.082683f,
-0.084452f,
-0.086195f,
-0.087911f,
-0.089601f,
-0.091265f,
-0.092902f,
-0.094513f,
-0.096097f,
-0.097656f,
-0.099188f,
-0.100693f,
-0.102173f,
-0.103626f,
-0.105053f,
-0.106454f,
-0.107830f,
-0.109179f,
-0.110502f,
-0.111799f,
-0.113070f,
-0.114316f,
-0.115536f,
-0.116730f,
-0.117899f,
-0.119042f,
-0.120159f,
-0.121251f,
-0.122318f,
-0.123360f,
-0.124376f,
-0.125368f,
-0.126334f,
-0.127275f,
-0.128192f,
-0.129083f,
-0.129950f,
-0.130793f,
-0.131611f,
-0.132404f,
-0.133174f,
-0.133919f,
-0.134640f,
-0.135337f,
-0.136010f,
-0.136659f,
-0.137284f,
-0.137886f,
-0.138465f,
-0.139020f,
-0.139552f,
-0.140061f,
-0.140547f,
-0.141010f,
-0.141451f,
-0.141868f,
-0.142263f,
-0.142636f,
-0.142987f,
-0.143316f,
-0.143622f,
-0.143907f,
-0.144170f,
-0.144412f,
-0.144632f,
-0.144830f,
-0.145008f,
-0.145165f,
-0.145301f,
-0.145416f,
-0.145511f,
-0.145585f,
-0.145639f,
-0.145673f,
-0.145687f,
-0.145681f,
-0.145656f,
-0.145611f,
-0.145547f,
-0.145464f,
-0.145361f,
-0.145240f,
-0.145100f,
-0.144942f,
-0.144766f,
-0.144571f,
-0.144358f,
-0.144127f,
-0.143879f,
-0.143613f,
-0.143330f,
-0.143030f,
-0.142713f,
-0.142379f,
-0.142028f,
-0.141661f,
-0.141278f,
-0.140878f,
-0.140463f,
-0.140032f,
-0.139585f,
-0.139123f,
-0.138646f,
-0.138153f,
-0.137646f,
-0.137124f,
-0.136588f,
-0.136037f,
-0.135473f,
-0.134894f,
-0.134302f,
-0.133696f,
-0.133076f,
-0.132444f,
-0.131798f,
-0.131140f,
-0.130469f,
-0.129785f,
-0.129089f,
-0.128381f,
-0.127662f,
-0.126930f,
-0.126187f,
-0.125433f,
-0.124668f,
-0.123891f,
-0.123104f,
-0.122306f,
-0.121498f,
-0.120680f,
-0.119851f,
-0.119013f,
-0.118165f,
-0.117308f,
-0.116441f,
-0.115565f,
-0.114681f,
-0.113788f,
-0.112886f,
-0.111976f,
-0.111057f,
-0.110131f,
-0.109197f,
-0.108255f,
-0.107306f,
-0.106350f,
-0.105386f,
-0.104416f,
-0.103439f,
-0.102455f,
-0.101466f,
-0.100470f,
-0.099468f,
-0.098460f,
-0.097447f,
-0.096428f,
-0.095404f,
-0.094375f,
-0.093341f,
-0.092303f,
-0.091260f,
-0.090212f,
-0.089161f,
-0.088105f,
-0.087046f,
-0.085982f,
-0.084916f,
-0.083846f,
-0.082773f,
-0.081697f,
-0.080618f,
-0.079536f,
-0.078452f,
-0.077366f,
-0.076277f,
-0.075187f,
-0.074095f,
-0.073001f,
-0.071905f,
-0.070808f,
-0.069710f,
-0.068611f,
-0.067512f,
-0.066411f,
-0.065310f,
-0.064209f,
-0.063107f,
-0.062005f,
-0.060903f,
-0.059802f,
-0.058701f,
-0.057600f,
-0.056500f,
-0.055401f,
-0.054303f,
-0.053206f,
-0.052110f,
-0.051015f,
-0.049922f,
-0.048831f,
-0.047741f,
-0.046654f,
-0.045568f,
-0.044485f,
-0.043403f,
-0.042325f,
-0.041249f,
-0.040175f,
-0.039105f,
-0.038037f,
-0.036973f,
-0.035912f,
-0.034854f,
-0.033799f,
-0.032749f,
-0.031701f,
-0.030658f,
-0.029619f,
-0.028583f,
-0.027552f,
-0.026525f,
-0.025502f,
-0.024484f,
-0.023471f,
-0.022462f,
-0.021458f,
-0.020459f,
-0.019464f,
-0.018475f,
-0.017491f,
-0.016513f,
-0.015539f,
-0.014572f,
-0.013610f,
-0.012653f,
-0.011702f,
-0.010757f,
-0.009818f,
-0.008885f,
-0.007958f,
-0.007038f,
-0.006123f,
-0.005215f,
-0.004313f,
-0.003418f,
-0.002530f,
-0.001648f,
-0.000772f,
0.000096f,
0.000958f,
0.001813f,
0.002660f,
0.003501f,
0.004335f,
0.005161f,
0.005980f,
0.006792f,
0.007597f,
0.008394f,
0.009183f,
0.009965f,
0.010740f,
0.011507f,
0.012266f,
0.013018f,
0.013762f,
0.014498f,
0.015226f,
0.015946f,
0.016658f,
0.017363f,
0.018059f,
0.018747f,
0.019428f,
0.020100f,
0.020764f,
0.021420f,
0.022067f,
0.022707f,
0.023338f,
0.023961f,
0.024575f,
0.025181f,
0.025779f,
0.026369f,
0.026950f,
0.027523f,
0.028087f,
0.028643f,
0.029191f,
0.029730f,
0.030260f,
0.030782f,
0.031296f,
0.031801f,
0.032297f,
0.032785f,
0.033265f,
0.033736f,
0.034199f,
0.034653f,
0.035098f,
0.035536f,
0.035964f,
0.036384f,
0.036796f,
0.037199f,
0.037594f,
0.037980f,
0.038358f,
0.038727f,
0.039088f,
0.039441f,
0.039785f,
0.040121f,
0.040448f,
0.040768f,
0.041078f,
0.041381f,
0.041675f,
0.041961f,
0.042239f,
0.042509f,
0.042770f,
0.043024f,
0.043269f,
0.043506f,
0.043735f,
0.043956f,
0.044169f,
0.044375f,
0.044572f,
0.044761f,
0.044943f,
0.045116f,
0.045282f,
0.045440f,
0.045591f,
0.045734f,
0.045869f,
0.045996f,
0.046117f,
0.046229f,
0.046334f,
0.046432f,
0.046522f,
0.046605f,
0.046681f,
0.046750f,
0.046811f,
0.046865f,
0.046913f,
0.046953f,
0.046986f,
0.047012f,
0.047032f,
0.047044f,
0.047050f,
0.047049f,
0.047042f,
0.047028f,
0.047007f,
0.046980f,
0.046946f,
0.046907f,
0.046860f,
0.046808f,
0.046749f,
0.046684f,
0.046613f,
0.046536f,
0.046453f,
0.046365f,
0.046270f,
0.046169f,
0.046063f,
0.045951f,
0.045834f,
0.045711f,
0.045583f,
0.045449f,
0.045310f,
0.045165f,
0.045016f,
0.044861f,
0.044701f,
0.044536f,
0.044366f,
0.044192f,
0.044012f,
0.043828f,
0.043639f,
0.043445f,
0.043247f,
0.043045f,
0.042838f,
0.042626f,
0.042411f,
0.042191f,
0.041967f,
0.041738f,
0.041506f,
0.041270f,
0.041030f,
0.040786f,
0.040539f,
0.040288f,
0.040033f,
0.039774f,
0.039513f,
0.039247f,
0.038979f,
0.038707f,
0.038432f,
0.038154f,
0.037872f,
0.037588f,
0.037301f,
0.037011f,
0.036718f,
0.036422f,
0.036124f,
0.035823f,
0.035520f,
0.035214f,
0.034906f,
0.034595f,
0.034282f,
0.033967f,
0.033650f,
0.033330f,
0.033009f,
0.032686f,
0.032361f,
0.032034f,
0.031705f,
0.031375f,
0.031043f,
0.030709f,
0.030374f,
0.030037f,
0.029700f,
0.029360f,
0.029020f,
0.028678f,
0.028336f,
0.027992f,
0.027647f,
0.027301f,
0.026955f,
0.026607f,
0.026259f,
0.025910f,
0.025561f,
0.025210f,
0.024860f,
0.024508f,
0.024157f,
0.023805f,
0.023453f,
0.023100f,
0.022748f,
0.022395f,
0.022042f,
0.021689f,
0.021336f,
0.020983f,
0.020630f,
0.020278f,
0.019926f,
0.019573f,
0.019222f,
0.018870f,
0.018520f,
0.018169f,
0.017819f,
0.017470f,
0.017121f,
0.016773f,
0.016426f,
0.016080f,
0.015734f,
0.015389f,
0.015045f,
0.014702f,
0.014360f,
0.014019f,
0.013679f,
0.013341f,
0.013003f,
0.012667f,
0.012332f,
0.011998f,
0.011665f,
0.011334f,
0.011004f,
0.010676f,
0.010349f,
0.010024f,
0.009700f,
0.009377f,
0.009057f,
0.008738f,
0.008421f,
0.008105f,
0.007791f,
0.007479f,
0.007169f,
0.006861f,
0.006554f,
0.006249f,
0.005947f,
0.005646f,
0.005347f,
0.005051f,
0.004756f,
0.004464f,
0.004173f,
0.003885f,
0.003599f,
0.003315f,
0.003033f,
0.002753f,
0.002476f,
0.002201f,
0.001928f,
0.001658f,
0.001390f,
0.001124f,
0.000861f,
0.000600f,
0.000341f,
0.000085f,
-0.000169f,
-0.000420f,
-0.000669f,
-0.000915f,
-0.001159f,
-0.001400f,
-0.001639f,
-0.001875f,
-0.002109f,
-0.002340f,
-0.002568f,
-0.002794f,
-0.003017f,
-0.003238f,
-0.003456f,
-0.003671f,
-0.003884f,
-0.004094f,
-0.004301f,
-0.004506f,
-0.004708f,
-0.004907f,
-0.005104f,
-0.005298f,
-0.005489f,
-0.005678f,
-0.005863f,
-0.006046f,
-0.006227f,
-0.006405f,
-0.006579f,
-0.006752f,
-0.006921f,
-0.007088f,
-0.007252f,
-0.007413f,
-0.007572f,
-0.007728f,
-0.007881f,
-0.008031f,
-0.008179f,
-0.008324f,
-0.008466f,
-0.008606f,
-0.008743f,
-0.008877f,
-0.009008f,
-0.009137f,
-0.009263f,
-0.009387f,
-0.009507f,
-0.009626f,
-0.009741f,
-0.009854f,
-0.009964f,
-0.010071f,
-0.010176f,
-0.010278f,
-0.010378f,
-0.010475f,
-0.010569f,
-0.010661f,
-0.010751f,
-0.010837f,
-0.010922f,
-0.011003f,
-0.011082f,
-0.011159f,
-0.011233f,
-0.011305f,
-0.011374f,
-0.011441f,
-0.011505f,
-0.011567f,
-0.011626f,
-0.011683f,
-0.011738f,
-0.011790f,
-0.011840f,
-0.011887f,
-0.011932f,
-0.011975f,
-0.012016f,
-0.012054f,
-0.012090f,
-0.012124f,
-0.012156f,
-0.012185f,
-0.012212f,
-0.012237f,
-0.012260f,
-0.012281f,
-0.012299f,
-0.012316f,
-0.012330f,
-0.012342f,
-0.012352f,
-0.012361f,
-0.012367f,
-0.012371f,
-0.012373f,
-0.012374f,
-0.012372f,
-0.012368f,
-0.012363f,
-0.012356f,
-0.012346f,
-0.012335f,
-0.012323f,
-0.012308f,
-0.012292f,
-0.012274f,
-0.012254f,
-0.012232f,
-0.012209f,
-0.012184f,
-0.012157f,
-0.012129f,
-0.012099f,
-0.012068f,
-0.012035f,
-0.012001f,
-0.011965f,
-0.011927f,
-0.011888f,
-0.011848f,
-0.011806f,
-0.011763f,
-0.011718f,
-0.011672f,
-0.011625f,
-0.011576f,
-0.011527f,
-0.011475f,
-0.011423f,
-0.011369f,
-0.011314f,
-0.011258f,
-0.011201f,
-0.011143f,
-0.011083f,
-0.011022f,
-0.010961f,
-0.010898f,
-0.010834f,
-0.010769f,
-0.010704f,
-0.010637f,
-0.010569f,
-0.010501f,
-0.010431f,
-0.010361f,
-0.010289f,
-0.010217f,
-0.010144f,
-0.010070f,
-0.009996f,
-0.009921f,
-0.009845f,
-0.009768f,
-0.009690f,
-0.009612f,
-0.009533f,
-0.009454f,
-0.009374f,
-0.009293f,
-0.009212f,
-0.009130f,
-0.009048f,
-0.008965f,
-0.008882f,
-0.008798f,
-0.008714f,
-0.008629f,
-0.008544f,
-0.008459f,
-0.008373f,
-0.008287f,
-0.008200f,
-0.008113f,
-0.008026f,
-0.007938f,
-0.007851f,
-0.007763f,
-0.007674f,
-0.007586f,
-0.007497f,
-0.007408f,
-0.007319f,
-0.007230f,
-0.007141f,
-0.007051f,
-0.006962f,
-0.006872f,
-0.006783f,
-0.006693f,
-0.006603f,
-0.006514f,
-0.006424f,
-0.006334f,
-0.006244f,
-0.006155f,
-0.006065f,
-0.005976f,
-0.005886f,
-0.005797f,
-0.005708f,
-0.005619f,
-0.005530f,
-0.005441f,
-0.005352f,
-0.005264f,
-0.005176f,
-0.005088f,
-0.005000f,
-0.004912f,
-0.004825f,
-0.004738f,
-0.004651f,
-0.004565f,
-0.004479f,
-0.004393f,
-0.004307f,
-0.004222f,
-0.004137f,
-0.004053f,
-0.003969f,
-0.003885f,
-0.003802f,
-0.003719f,
-0.003636f,
-0.003554f,
-0.003472f,
-0.003391f,
-0.003310f,
-0.003230f,
-0.003150f,
-0.003071f,
-0.002992f,
-0.002913f,
-0.002835f,
-0.002758f,
-0.002681f,
-0.002604f,
-0.002528f,
-0.002453f,
-0.002378f,
-0.002304f,
-0.002230f,
-0.002157f,
-0.002084f,
-0.002012f,
-0.001941f,
-0.001870f,
-0.001800f,
-0.001730f,
-0.001661f,
-0.001593f,
-0.001525f,
-0.001458f,
-0.001391f,
-0.001325f,
-0.001260f,
-0.001195f,
-0.001131f,
-0.001068f,
-0.001005f,
-0.000943f,
-0.000881f,
-0.000821f,
-0.000760f,
-0.000701f,
-0.000642f,
-0.000584f,
-0.000526f,
-0.000470f,
-0.000413f,
-0.000358f,
-0.000303f,
-0.000249f,
-0.000196f,
-0.000143f,
-0.000091f,
-0.000039f,
0.000011f,
0.000061f,
0.000111f,
0.000159f,
0.000207f,
0.000254f,
0.000301f,
0.000347f,
0.000392f,
0.000437f,
0.000480f,
0.000523f,
0.000566f,
0.000608f,
0.000649f,
0.000689f,
0.000729f,
0.000768f,
0.000806f,
0.000844f,
0.000881f,
0.000917f,
0.000953f,
0.000988f,
0.001022f,
0.001056f,
0.001089f,
0.001121f,
0.001153f,
0.001184f,
0.001214f,
0.001244f,
0.001273f,
0.001302f,
0.001329f,
0.001356f,
0.001383f,
0.001409f,
0.001434f,
0.001459f,
0.001483f,
0.001506f,
0.001529f,
0.001551f,
0.001573f,
0.001594f,
0.001614f,
0.001634f,
0.001653f,
0.001671f,
0.001689f,
0.001707f,
0.001724f,
0.001740f,
0.001756f,
0.001771f,
0.001785f,
0.001799f,
0.001813f,
0.001826f,
0.001838f,
0.001850f,
0.001862f,
0.001872f,
0.001883f,
0.001893f,
0.001902f,
0.001911f,
0.001919f,
0.001927f,
0.001934f,
0.001941f,
0.001947f,
0.001953f,
0.001959f,
0.001964f,
0.001968f,
0.001972f,
0.001976f,
0.001979f,
0.001982f,
0.001984f,
0.001986f,
0.001988f,
0.001989f,
0.001990f,
0.001990f,
0.001990f,
0.001989f,
0.001988f,
0.001987f,
0.001986f,
0.001984f,
0.001981f,
0.001979f,
0.001976f,
0.001972f,
0.001968f,
0.001964f,
0.001960f,
0.001955f,
0.001950f,
0.001945f,
0.001939f,
0.001933f,
0.001927f,
0.001921f,
0.001914f,
0.001907f,
0.001900f,
0.001892f,
0.001884f,
0.001876f,
0.001868f,
0.001859f,
0.001850f,
0.001841f,
0.001832f,
0.001822f,
0.001813f,
0.001803f,
0.001792f,
0.001782f,
0.001772f,
0.001761f,
0.001750f,
0.001739f,
0.001727f,
0.001716f,
0.001704f,
0.001693f,
0.001681f,
0.001669f,
0.001656f,
0.001644f,
0.001631f,
0.001619f,
0.001606f,
0.001593f,
0.001580f,
0.001567f,
0.001554f,
0.001540f,
0.001527f,
0.001514f,
0.001500f,
0.001486f,
0.001472f,
0.001459f,
0.001445f,
0.001431f,
0.001417f,
0.001402f,
0.001388f,
0.001374f,
0.001360f,
0.001345f,
0.001331f,
0.001317f,
0.001302f,
0.001288f,
0.001273f,
0.001259f,
0.001244f,
0.001230f,
0.001215f,
0.001200f,
0.001186f,
0.001171f,
0.001157f,
0.001142f,
0.001128f,
0.001113f,
0.001098f,
0.001084f,
0.001069f,
0.001055f,
0.001041f,
0.001026f,
0.001012f,
0.000997f,
0.000983f,
0.000969f,
0.000955f,
0.000940f,
0.000926f,
0.000912f,
0.000898f,
0.000884f,
0.000870f,
0.000856f,
0.000843f,
0.000829f,
0.000815f,
0.000802f,
0.000788f,
0.000775f,
0.000761f,
0.000748f,
0.000735f,
0.000722f,
0.000709f,
0.000696f,
0.000683f,
0.000670f,
0.000657f,
0.000645f,
0.000632f,
0.000620f,
0.000608f,
0.000595f,
0.000583f,
0.000571f,
0.000559f,
0.000547f,
0.000536f,
0.000524f,
0.000512f,
0.000501f,
0.000490f,
0.000479f,
0.000467f,
0.000456f,
0.000446f,
0.000435f,
0.000424f,
0.000414f,
0.000403f,
0.000393f,
0.000383f,
0.000373f,
0.000363f,
0.000353f,
0.000343f,
0.000333f,
0.000324f,
0.000315f,
0.000305f,
0.000296f,
0.000287f,
0.000278f,
0.000269f,
0.000261f,
0.000252f,
0.000244f,
0.000235f,
0.000227f,
0.000219f,
0.000211f,
0.000203f,
0.000196f,
0.000188f,
0.000181f,
0.000173f,
0.000166f,
0.000159f,
0.000152f,
0.000145f,
0.000138f,
0.000131f,
0.000125f,
0.000118f,
0.000112f,
0.000106f,
0.000100f,
0.000094f,
0.000088f,
0.000082f,
0.000077f,
0.000071f,
0.000066f,
0.000060f,
0.000055f,
0.000050f,
0.000045f,
0.000040f,
0.000035f,
0.000031f,
0.000026f,
0.000022f,
0.000017f,
0.000013f,
0.000009f,
0.000005f,
0.000001f,
-0.000003f,
-0.000007f,
-0.000010f,
-0.000014f,
-0.000017f,
-0.000021f,
-0.000024f,
-0.000027f,
-0.000030f,
-0.000033f,
-0.000036f,
-0.000039f,
-0.000042f,
-0.000044f,
-0.000047f,
-0.000049f,
-0.000052f,
-0.000054f,
-0.000056f,
-0.000059f,
-0.000061f,
-0.000063f,
-0.000065f,
-0.000066f,
-0.000068f,
-0.000070f,
-0.000071f,
-0.000073f,
-0.000074f,
-0.000076f,
-0.000077f,
-0.000078f,
-0.000080f,
-0.000081f,
-0.000082f,
-0.000083f,
-0.000084f,
-0.000085f,
-0.000085f,
-0.000086f,
-0.000087f,
-0.000087f,
-0.000088f,
-0.000089f,
-0.000089f,
-0.000089f,
-0.000090f,
-0.000090f,
-0.000090f,
-0.000091f,
-0.000091f,
-0.000091f,
-0.000091f,
-0.000091f,
-0.000091f,
-0.000091f,
-0.000091f,
-0.000091f,
-0.000090f,
-0.000090f,
-0.000090f,
-0.000090f,
-0.000089f,
-0.000089f,
-0.000089f,
-0.000088f,
-0.000088f,
-0.000087f,
-0.000087f,
-0.000086f,
-0.000085f,
-0.000085f,
-0.000084f,
-0.000084f,
-0.000083f,
-0.000082f,
-0.000081f,
-0.000081f,
-0.000080f,
-0.000079f,
-0.000078f,
-0.000077f,
-0.000077f,
-0.000076f,
-0.000075f,
-0.000074f,
-0.000073f,
-0.000072f,
-0.000071f,
-0.000070f,
-0.000069f,
-0.000068f,
-0.000067f,
-0.000066f,
-0.000065f,
-0.000064f,
-0.000063f,
-0.000062f,
-0.000061f,
-0.000060f,
-0.000059f,
-0.000058f,
-0.000057f,
-0.000056f,
-0.000055f,
-0.000054f,
-0.000052f,
-0.000051f,
-0.000050f,
-0.000049f,
-0.000048f,
-0.000047f,
-0.000046f
};

static float SMALL_FILTER_FLOAT_IMPD[] /* Impulse response */ = {
-0.000020f,
-0.000060f,
-0.000100f,
-0.000139f,
-0.000179f,
-0.000219f,
-0.000259f,
-0.000299f,
-0.000338f,
-0.000378f,
-0.000418f,
-0.000457f,
-0.000497f,
-0.000536f,
-0.000576f,
-0.000615f,
-0.000655f,
-0.000694f,
-0.000733f,
-0.000772f,
-0.000812f,
-0.000851f,
-0.000890f,
-0.000929f,
-0.000967f,
-0.001006f,
-0.001045f,
-0.001083f,
-0.001122f,
-0.001160f,
-0.001199f,
-0.001237f,
-0.001275f,
-0.001313f,
-0.001351f,
-0.001388f,
-0.001426f,
-0.001463f,
-0.001501f,
-0.001538f,
-0.001575f,
-0.001612f,
-0.001649f,
-0.001685f,
-0.001722f,
-0.001758f,
-0.001794f,
-0.001830f,
-0.001866f,
-0.001902f,
-0.001938f,
-0.001973f,
-0.002008f,
-0.002043f,
-0.002078f,
-0.002113f,
-0.002147f,
-0.002182f,
-0.002216f,
-0.002250f,
-0.002284f,
-0.002317f,
-0.002350f,
-0.002384f,
-0.002417f,
-0.002449f,
-0.002482f,
-0.002514f,
-0.002546f,
-0.002578f,
-0.002610f,
-0.002641f,
-0.002672f,
-0.002703f,
-0.002734f,
-0.002765f,
-0.002795f,
-0.002825f,
-0.002855f,
-0.002884f,
-0.002913f,
-0.002942f,
-0.002971f,
-0.003000f,
-0.003028f,
-0.003056f,
-0.003084f,
-0.003111f,
-0.003139f,
-0.003166f,
-0.003192f,
-0.003219f,
-0.003245f,
-0.003271f,
-0.003296f,
-0.003322f,
-0.003347f,
-0.003372f,
-0.003396f,
-0.003420f,
-0.003444f,
-0.003468f,
-0.003491f,
-0.003514f,
-0.003537f,
-0.003559f,
-0.003582f,
-0.003604f,
-0.003625f,
-0.003646f,
-0.003667f,
-0.003688f,
-0.003708f,
-0.003728f,
-0.003748f,
-0.003767f,
-0.003787f,
-0.003805f,
-0.003824f,
-0.003842f,
-0.003860f,
-0.003877f,
-0.003895f,
-0.003912f,
-0.003928f,
-0.003944f,
-0.003960f,
-0.003976f,
-0.003991f,
-0.004006f,
-0.004021f,
-0.004035f,
-0.004049f,
-0.004063f,
-0.004076f,
-0.004089f,
-0.004102f,
-0.004114f,
-0.004126f,
-0.004138f,
-0.004149f,
-0.004161f,
-0.004171f,
-0.004182f,
-0.004192f,
-0.004201f,
-0.004211f,
-0.004220f,
-0.004229f,
-0.004237f,
-0.004245f,
-0.004253f,
-0.004260f,
-0.004267f,
-0.004274f,
-0.004280f,
-0.004286f,
-0.004292f,
-0.004297f,
-0.004303f,
-0.004307f,
-0.004312f,
-0.004316f,
-0.004320f,
-0.004323f,
-0.004326f,
-0.004329f,
-0.004331f,
-0.004333f,
-0.004335f,
-0.004337f,
-0.004338f,
-0.004339f,
-0.004339f,
-0.004339f,
-0.004339f,
-0.004338f,
-0.004338f,
-0.004337f,
-0.004335f,
-0.004333f,
-0.004331f,
-0.004329f,
-0.004326f,
-0.004323f,
-0.004320f,
-0.004316f,
-0.004312f,
-0.004308f,
-0.004303f,
-0.004298f,
-0.004293f,
-0.004288f,
-0.004282f,
-0.004276f,
-0.004269f,
-0.004263f,
-0.004256f,
-0.004248f,
-0.004241f,
-0.004233f,
-0.004225f,
-0.004216f,
-0.004207f,
-0.004198f,
-0.004189f,
-0.004179f,
-0.004170f,
-0.004159f,
-0.004149f,
-0.004138f,
-0.004127f,
-0.004116f,
-0.004104f,
-0.004092f,
-0.004080f,
-0.004068f,
-0.004055f,
-0.004043f,
-0.004029f,
-0.004016f,
-0.004002f,
-0.003988f,
-0.003974f,
-0.003960f,
-0.003945f,
-0.003930f,
-0.003915f,
-0.003900f,
-0.003884f,
-0.003868f,
-0.003852f,
-0.003836f,
-0.003819f,
-0.003803f,
-0.003786f,
-0.003768f,
-0.003751f,
-0.003733f,
-0.003716f,
-0.003697f,
-0.003679f,
-0.003661f,
-0.003642f,
-0.003623f,
-0.003604f,
-0.003585f,
-0.003565f,
-0.003545f,
-0.003526f,
-0.003506f,
-0.003485f,
-0.003465f,
-0.003444f,
-0.003423f,
-0.003402f,
-0.003381f,
-0.003360f,
-0.003339f,
-0.003317f,
-0.003295f,
-0.003273f,
-0.003251f,
-0.003229f,
-0.003206f,
-0.003184f,
-0.003161f,
-0.003138f,
-0.003115f,
-0.003092f,
-0.003069f,
-0.003045f,
-0.003022f,
-0.002998f,
-0.002974f,
-0.002951f,
-0.002927f,
-0.002902f,
-0.002878f,
-0.002854f,
-0.002829f,
-0.002805f,
-0.002780f,
-0.002755f,
-0.002731f,
-0.002706f,
-0.002681f,
-0.002655f,
-0.002630f,
-0.002605f,
-0.002580f,
-0.002554f,
-0.002529f,
-0.002503f,
-0.002477f,
-0.002452f,
-0.002426f,
-0.002400f,
-0.002374f,
-0.002348f,
-0.002322f,
-0.002296f,
-0.002270f,
-0.002244f,
-0.002218f,
-0.002191f,
-0.002165f,
-0.002139f,
-0.002113f,
-0.002086f,
-0.002060f,
-0.002034f,
-0.002007f,
-0.001981f,
-0.001954f,
-0.001928f,
-0.001901f,
-0.001875f,
-0.001849f,
-0.001822f,
-0.001796f,
-0.001769f,
-0.001743f,
-0.001716f,
-0.001690f,
-0.001664f,
-0.001637f,
-0.001611f,
-0.001585f,
-0.001558f,
-0.001532f,
-0.001506f,
-0.001480f,
-0.001453f,
-0.001427f,
-0.001401f,
-0.001375f,
-0.001349f,
-0.001323f,
-0.001297f,
-0.001271f,
-0.001246f,
-0.001220f,
-0.001194f,
-0.001169f,
-0.001143f,
-0.001118f,
-0.001092f,
-0.001067f,
-0.001042f,
-0.001016f,
-0.000991f,
-0.000966f,
-0.000941f,
-0.000916f,
-0.000892f,
-0.000867f,
-0.000842f,
-0.000818f,
-0.000794f,
-0.000769f,
-0.000745f,
-0.000721f,
-0.000697f,
-0.000673f,
-0.000649f,
-0.000626f,
-0.000602f,
-0.000579f,
-0.000555f,
-0.000532f,
-0.000509f,
-0.000486f,
-0.000463f,
-0.000440f,
-0.000418f,
-0.000395f,
-0.000373f,
-0.000351f,
-0.000329f,
-0.000307f,
-0.000285f,
-0.000263f,
-0.000242f,
-0.000220f,
-0.000199f,
-0.000178f,
-0.000157f,
-0.000136f,
-0.000115f,
-0.000095f,
-0.000074f,
-0.000054f,
-0.000034f,
-0.000014f,
0.000006f,
0.000025f,
0.000045f,
0.000064f,
0.000083f,
0.000102f,
0.000121f,
0.000140f,
0.000158f,
0.000177f,
0.000195f,
0.000213f,
0.000231f,
0.000248f,
0.000266f,
0.000283f,
0.000300f,
0.000317f,
0.000334f,
0.000351f,
0.000367f,
0.000383f,
0.000399f,
0.000415f,
0.000431f,
0.000447f,
0.000462f,
0.000477f,
0.000492f,
0.000507f,
0.000522f,
0.000536f,
0.000551f,
0.000565f,
0.000579f,
0.000592f,
0.000606f,
0.000619f,
0.000633f,
0.000646f,
0.000658f,
0.000671f,
0.000684f,
0.000696f,
0.000708f,
0.000720f,
0.000731f,
0.000743f,
0.000754f,
0.000765f,
0.000776f,
0.000787f,
0.000798f,
0.000808f,
0.000818f,
0.000828f,
0.000838f,
0.000848f,
0.000857f,
0.000867f,
0.000876f,
0.000885f,
0.000893f,
0.000902f,
0.000910f,
0.000918f,
0.000926f,
0.000934f,
0.000942f,
0.000949f,
0.000956f,
0.000963f,
0.000970f,
0.000977f,
0.000983f,
0.000990f,
0.000996f,
0.001002f,
0.001008f,
0.001013f,
0.001019f,
0.001024f,
0.001029f,
0.001034f,
0.001039f,
0.001043f,
0.001047f,
0.001052f,
0.001056f,
0.001059f,
0.001063f,
0.001067f,
0.001070f,
0.001073f,
0.001076f,
0.001079f,
0.001082f,
0.001084f,
0.001086f,
0.001088f,
0.001090f,
0.001092f,
0.001094f,
0.001095f,
0.001097f,
0.001098f,
0.001099f,
0.001100f,
0.001101f,
0.001101f,
0.001101f,
0.001102f,
0.001102f,
0.001102f,
0.001102f,
0.001101f,
0.001101f,
0.001100f,
0.001099f,
0.001098f,
0.001097f,
0.001096f,
0.001095f,
0.001093f,
0.001091f,
0.001090f,
0.001088f,
0.001086f,
0.001083f,
0.001081f,
0.001079f,
0.001076f,
0.001073f,
0.001070f,
0.001068f,
0.001064f,
0.001061f,
0.001058f,
0.001054f,
0.001051f,
0.001047f,
0.001043f,
0.001039f,
0.001035f,
0.001031f,
0.001027f,
0.001023f,
0.001018f,
0.001014f,
0.001009f,
0.001004f,
0.000999f,
0.000994f,
0.000989f,
0.000984f,
0.000979f,
0.000973f,
0.000968f,
0.000962f,
0.000957f,
0.000951f,
0.000945f,
0.000939f,
0.000933f,
0.000927f,
0.000921f,
0.000914f,
0.000908f,
0.000902f,
0.000895f,
0.000889f,
0.000882f,
0.000875f,
0.000869f,
0.000862f,
0.000855f,
0.000848f,
0.000841f,
0.000834f,
0.000826f,
0.000819f,
0.000812f,
0.000805f,
0.000797f,
0.000790f,
0.000782f,
0.000775f,
0.000767f,
0.000759f,
0.000752f,
0.000744f,
0.000736f,
0.000728f,
0.000720f,
0.000712f,
0.000704f,
0.000696f,
0.000688f,
0.000680f,
0.000672f,
0.000664f,
0.000656f,
0.000648f,
0.000639f,
0.000631f,
0.000623f,
0.000615f,
0.000606f,
0.000598f,
0.000590f,
0.000581f,
0.000573f,
0.000564f,
0.000556f,
0.000547f,
0.000539f,
0.000531f,
0.000522f,
0.000514f,
0.000505f,
0.000497f,
0.000488f,
0.000480f,
0.000471f,
0.000463f,
0.000454f,
0.000446f,
0.000437f,
0.000429f,
0.000420f,
0.000412f,
0.000403f,
0.000395f,
0.000386f,
0.000378f,
0.000369f,
0.000361f,
0.000353f,
0.000344f,
0.000336f,
0.000327f,
0.000319f,
0.000311f,
0.000303f,
0.000294f,
0.000286f,
0.000278f,
0.000270f,
0.000261f,
0.000253f,
0.000245f,
0.000237f,
0.000229f,
0.000221f,
0.000213f,
0.000205f,
0.000197f,
0.000189f,
0.000181f,
0.000174f,
0.000166f,
0.000158f,
0.000150f,
0.000143f,
0.000135f,
0.000128f,
0.000120f,
0.000113f,
0.000105f,
0.000098f,
0.000090f,
0.000083f,
0.000076f,
0.000069f,
0.000061f,
0.000054f,
0.000047f,
0.000040f,
0.000033f,
0.000026f,
0.000019f,
0.000013f,
0.000006f,
-0.000001f,
-0.000008f,
-0.000014f,
-0.000021f,
-0.000027f,
-0.000034f,
-0.000040f,
-0.000046f,
-0.000053f,
-0.000059f,
-0.000065f,
-0.000071f,
-0.000077f,
-0.000083f,
-0.000089f,
-0.000095f,
-0.000100f,
-0.000106f,
-0.000112f,
-0.000117f,
-0.000123f,
-0.000128f,
-0.000134f,
-0.000139f,
-0.000144f,
-0.000150f,
-0.000155f,
-0.000160f,
-0.000165f,
-0.000170f,
-0.000175f,
-0.000180f,
-0.000184f,
-0.000189f,
-0.000194f,
-0.000198f,
-0.000203f,
-0.000207f,
-0.000211f,
-0.000216f,
-0.000220f,
-0.000224f,
-0.000228f,
-0.000232f,
-0.000236f,
-0.000240f,
-0.000244f,
-0.000248f,
-0.000251f,
-0.000255f,
-0.000258f,
-0.000262f,
-0.000265f,
-0.000269f,
-0.000272f,
-0.000275f,
-0.000278f,
-0.000281f,
-0.000284f,
-0.000287f,
-0.000290f,
-0.000293f,
-0.000296f,
-0.000298f,
-0.000301f,
-0.000303f,
-0.000306f,
-0.000308f,
-0.000311f,
-0.000313f,
-0.000315f,
-0.000317f,
-0.000319f,
-0.000321f,
-0.000323f,
-0.000325f,
-0.000327f,
-0.000329f,
-0.000330f,
-0.000332f,
-0.000334f,
-0.000335f,
-0.000337f,
-0.000338f,
-0.000339f,
-0.000340f,
-0.000342f,
-0.000343f,
-0.000344f,
-0.000345f,
-0.000346f,
-0.000347f,
-0.000347f,
-0.000348f,
-0.000349f,
-0.000350f,
-0.000350f,
-0.000351f,
-0.000351f,
-0.000352f,
-0.000352f,
-0.000352f,
-0.000352f,
-0.000353f,
-0.000353f,
-0.000353f,
-0.000353f,
-0.000353f,
-0.000353f,
-0.000353f,
-0.000353f,
-0.000352f,
-0.000352f,
-0.000352f,
-0.000351f,
-0.000351f,
-0.000350f,
-0.000350f,
-0.000349f,
-0.000349f,
-0.000348f,
-0.000347f,
-0.000346f,
-0.000346f,
-0.000345f,
-0.000344f,
-0.000343f,
-0.000342f,
-0.000341f,
-0.000340f,
-0.000339f,
-0.000338f,
-0.000336f,
-0.000335f,
-0.000334f,
-0.000333f,
-0.000331f,
-0.000330f,
-0.000328f,
-0.000327f,
-0.000325f,
-0.000324f,
-0.000322f,
-0.000321f,
-0.000319f,
-0.000317f,
-0.000316f,
-0.000314f,
-0.000312f,
-0.000310f,
-0.000308f,
-0.000306f,
-0.000305f,
-0.000303f,
-0.000301f,
-0.000299f,
-0.000297f,
-0.000295f,
-0.000293f,
-0.000290f,
-0.000288f,
-0.000286f,
-0.000284f,
-0.000282f,
-0.000280f,
-0.000277f,
-0.000275f,
-0.000273f,
-0.000270f,
-0.000268f,
-0.000266f,
-0.000263f,
-0.000261f,
-0.000259f,
-0.000256f,
-0.000254f,
-0.000251f,
-0.000249f,
-0.000246f,
-0.000244f,
-0.000241f,
-0.000239f,
-0.000236f,
-0.000234f,
-0.000231f,
-0.000228f,
-0.000226f,
-0.000223f,
-0.000221f,
-0.000218f,
-0.000215f,
-0.000213f,
-0.000210f,
-0.000207f,
-0.000205f,
-0.000202f,
-0.000199f,
-0.000197f,
-0.000194f,
-0.000191f,
-0.000189f,
-0.000186f,
-0.000183f,
-0.000180f,
-0.000178f,
-0.000175f,
-0.000172f,
-0.000169f,
-0.000167f,
-0.000164f,
-0.000161f,
-0.000159f,
-0.000156f,
-0.000153f,
-0.000150f,
-0.000148f,
-0.000145f,
-0.000142f,
-0.000140f,
-0.000137f,
-0.000134f,
-0.000131f,
-0.000129f,
-0.000126f,
-0.000123f,
-0.000121f,
-0.000118f,
-0.000115f,
-0.000113f,
-0.000110f,
-0.000107f,
-0.000105f,
-0.000102f,
-0.000100f,
-0.000097f,
-0.000094f,
-0.000092f,
-0.000089f,
-0.000087f,
-0.000084f,
-0.000082f,
-0.000079f,
-0.000077f,
-0.000074f,
-0.000072f,
-0.000069f,
-0.000067f,
-0.000064f,
-0.000062f,
-0.000059f,
-0.000057f,
-0.000055f,
-0.000052f,
-0.000050f,
-0.000048f,
-0.000045f,
-0.000043f,
-0.000041f,
-0.000038f,
-0.000036f,
-0.000034f,
-0.000032f,
-0.000029f,
-0.000027f,
-0.000025f,
-0.000023f,
-0.000021f,
-0.000019f,
-0.000016f,
-0.000014f,
-0.000012f,
-0.000010f,
-0.000008f,
-0.000006f,
-0.000004f,
-0.000002f,
-0.000000f,
0.000002f,
0.000004f,
0.000005f,
0.000007f,
0.000009f,
0.000011f,
0.000013f,
0.000015f,
0.000016f,
0.000018f,
0.000020f,
0.000022f,
0.000023f,
0.000025f,
0.000027f,
0.000028f,
0.000030f,
0.000031f,
0.000033f,
0.000034f,
0.000036f,
0.000037f,
0.000039f,
0.000040f,
0.000042f,
0.000043f,
0.000045f,
0.000046f,
0.000047f,
0.000049f,
0.000050f,
0.000051f,
0.000052f,
0.000054f,
0.000055f,
0.000056f,
0.000057f,
0.000058f,
0.000060f,
0.000061f,
0.000062f,
0.000063f,
0.000064f,
0.000065f,
0.000066f,
0.000067f,
0.000068f,
0.000069f,
0.000070f,
0.000070f,
0.000071f,
0.000072f,
0.000073f,
0.000074f,
0.000075f,
0.000075f,
0.000076f,
0.000077f,
0.000077f,
0.000078f,
0.000079f,
0.000079f,
0.000080f,
0.000081f,
0.000081f,
0.000082f,
0.000082f,
0.000083f,
0.000083f,
0.000084f,
0.000084f,
0.000085f,
0.000085f,
0.000085f,
0.000086f,
0.000086f,
0.000087f,
0.000087f,
0.000087f,
0.000087f,
0.000088f,
0.000088f,
0.000088f,
0.000088f,
0.000089f,
0.000089f,
0.000089f,
0.000089f,
0.000089f,
0.000089f,
0.000090f,
0.000090f,
0.000090f,
0.000090f,
0.000090f,
0.000090f,
0.000090f,
0.000090f,
0.000090f,
0.000090f,
0.000090f,
0.000090f,
0.000089f,
0.000089f,
0.000089f,
0.000089f,
0.000089f,
0.000089f,
0.000089f,
0.000088f,
0.000088f,
0.000088f,
0.000088f,
0.000088f,
0.000087f,
0.000087f,
0.000087f,
0.000086f,
0.000086f,
0.000086f,
0.000086f,
0.000085f,
0.000085f,
0.000084f,
0.000084f,
0.000084f,
0.000083f,
0.000083f,
0.000083f,
0.000082f,
0.000082f,
0.000081f,
0.000081f,
0.000080f,
0.000080f,
0.000079f,
0.000079f,
0.000078f,
0.000078f,
0.000077f,
0.000077f,
0.000076f,
0.000076f,
0.000075f,
0.000075f,
0.000074f,
0.000074f,
0.000073f,
0.000073f,
0.000072f,
0.000071f,
0.000071f,
0.000070f,
0.000070f,
0.000069f,
0.000068f,
0.000068f,
0.000067f,
0.000067f,
0.000066f,
0.000065f,
0.000065f,
0.000064f,
0.000063f,
0.000063f,
0.000062f,
0.000061f,
0.000061f,
0.000060f,
0.000059f,
0.000059f,
0.000058f,
0.000057f,
0.000057f,
0.000056f,
0.000055f,
0.000055f,
0.000054f,
0.000053f,
0.000053f,
0.000052f,
0.000051f,
0.000051f,
0.000050f,
0.000049f,
0.000049f,
0.000048f,
0.000047f,
0.000047f,
0.000046f,
0.000045f,
0.000045f,
0.000044f,
0.000043f,
0.000042f,
0.000042f,
0.000041f,
0.000040f,
0.000040f,
0.000039f,
0.000038f,
0.000038f,
0.000037f,
0.000036f,
0.000036f,
0.000035f,
0.000034f,
0.000034f,
0.000033f,
0.000032f,
0.000032f,
0.000031f,
0.000030f,
0.000030f,
0.000029f,
0.000028f,
0.000028f,
0.000027f,
0.000027f,
0.000026f,
0.000025f,
0.000025f,
0.000024f,
0.000023f,
0.000023f,
0.000022f,
0.000022f,
0.000021f,
0.000020f,
0.000020f,
0.000019f,
0.000019f,
0.000018f,
0.000017f,
0.000017f,
0.000016f,
0.000016f,
0.000015f,
0.000015f,
0.000014f,
0.000014f,
0.000013f,
0.000012f,
0.000012f,
0.000011f,
0.000011f,
0.000010f,
0.000010f,
0.000009f,
0.000009f,
0.000008f,
0.000008f,
0.000007f,
0.000007f,
0.000006f,
0.000006f,
0.000005f,
0.000005f,
0.000005f,
0.000004f,
0.000004f,
0.000003f,
0.000003f,
0.000002f,
0.000002f,
0.000002f,
0.000001f,
0.000001f,
0.000000f,
-0.000000f,
-0.000000f,
-0.000001f,
-0.000001f,
-0.000002f,
-0.000002f,
-0.000002f,
-0.000003f,
-0.000003f,
-0.000003f,
-0.000004f,
-0.000004f,
-0.000004f,
-0.000005f,
-0.000005f,
-0.000005f,
-0.000006f,
-0.000006f,
-0.000006f,
-0.000007f,
-0.000007f,
-0.000007f,
-0.000007f,
-0.000008f,
-0.000008f,
-0.000008f,
-0.000008f,
-0.000009f,
-0.000009f,
-0.000009f,
-0.000009f,
-0.000010f,
-0.000010f,
-0.000010f,
-0.000010f,
-0.000010f,
-0.000011f,
-0.000011f,
-0.000011f,
-0.000011f,
-0.000011f,
-0.000011f,
-0.000012f,
-0.000012f,
-0.000012f,
-0.000012f,
-0.000012f,
-0.000012f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000015f,
-0.000015f,
-0.000015f,
-0.000015f,
-0.000015f,
-0.000015f,
-0.000015f,
-0.000015f,
-0.000015f,
-0.000015f,
-0.000015f,
-0.000015f,
-0.000015f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000014f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000013f,
-0.000012f,
-0.000012f,
-0.000012f,
-0.000012f,
-0.000012f,
-0.000012f,
-0.000012f,
-0.000012f,
-0.000012f,
-0.000012f,
-0.000011f,
-0.000011f,
-0.000011f,
-0.000011f,
-0.000011f,
-0.000011f,
-0.000011f,
-0.000011f,
-0.000011f,
-0.000010f,
-0.000010f,
-0.000010f,
-0.000010f,
-0.000010f,
-0.000010f,
-0.000010f,
-0.000010f,
-0.000010f,
-0.000009f,
-0.000009f,
-0.000009f,
-0.000009f,
-0.000009f,
-0.000009f,
-0.000009f,
-0.000009f,
-0.000008f,
-0.000008f,
-0.000008f,
-0.000008f,
-0.000008f,
-0.000008f,
-0.000008f,
-0.000008f,
-0.000007f,
-0.000007f,
-0.000007f,
-0.000007f,
-0.000007f,
-0.000007f,
-0.000007f,
-0.000007f,
-0.000007f,
-0.000006f,
-0.000006f,
-0.000006f,
-0.000006f,
-0.000006f,
-0.000006f,
-0.000006f,
-0.000006f,
-0.000006f,
-0.000005f,
-0.000005f,
-0.000005f,
-0.000005f,
-0.000005f,
-0.000005f,
-0.000005f,
-0.000005f,
-0.000005f,
-0.000004f,
-0.000004f,
-0.000004f,
-0.000004f,
-0.000004f,
-0.000004f,
-0.000004f,
-0.000004f,
-0.000004f,
-0.000004f,
-0.000003f,
-0.000003f,
-0.000003f,
-0.000003f,
-0.000003f,
-0.000003f,
-0.000003f,
-0.000003f,
-0.000003f,
-0.000003f,
-0.000003f,
-0.000002f,
-0.000002f,
-0.000002f,
-0.000002f,
-0.000002f,
-0.000002f,
-0.000002f,
-0.000002f,
-0.000002f,
-0.000002f,
-0.000002f,
-0.000002f,
-0.000002f,
-0.000001f,
-0.000001f,
-0.000001f,
-0.000001f,
-0.000001f,
-0.000001f,
-0.000001f,
-0.000001f,
-0.000001f,
-0.000001f,
-0.000001f,
-0.000001f,
-0.000001f,
-0.000001f,
-0.000001f,
-0.000001f,
-0.000000f,
-0.000000f,
-0.000000f,
-0.000000f,
-0.000000f,
-0.000000f,
-0.000000f,
-0.000000f,
-0.000000f,
-0.000000f,
0.000000f,
0.000000f,
0.000000f,
0.000000f,
0.000000f,
0.000000f,
0.000000f,
0.000000f,
0.000000f,
0.000000f,
0.000000f,
0.000000f,
0.000000f,
0.000000f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f,
0.000001f
};

/*****************************************************************************
 * Local structures
 *****************************************************************************/
struct aout_filter_sys_t
{
    INT32 *p_buf;                        /* this filter introduces a delay */
    int i_buf_size;

    int i_old_rate;
    double d_old_factor;
    int i_old_wing;

    unsigned int i_remainder;                /* remainder of previous sample */

    audio_date_t end_date;
};

static int CreateFloat32ToS16Filter(aout_filter_t *p_filter);
static void DoFloat32ToS16( CAudioOutput * p_aout, aout_filter_t * p_filter,
                    aout_buffer_t * p_in_buf, aout_buffer_t * p_out_buf );
static int CreateS16ToFloat32Filter( aout_filter_t * p_filter );
static void DoS16toFloat32( CAudioOutput * p_aout, aout_filter_t * p_filter,
                    aout_buffer_t * p_in_buf, aout_buffer_t * p_out_buf );
static void DoS16toFloat32_24( CAudioOutput * p_aout, aout_filter_t * p_filter,
                    aout_buffer_t * p_in_buf, aout_buffer_t * p_out_buf );
static int CreateTrivialChannelMixer( aout_filter_t * p_filter );
static void DoTrivialChannelMixer( CAudioOutput * p_aout, aout_filter_t * p_filter,
                    aout_buffer_t * p_in_buf, aout_buffer_t * p_out_buf );
static int CreateBandlimitedResampler( aout_filter_t * p_filter );
static void DoBandlimitedResampler( CAudioOutput * p_aout, aout_filter_t * p_filter,
                    aout_buffer_t * p_in_buf, aout_buffer_t * p_out_buf );
void FilterFloatUP( float Imp[], float ImpD[], UINT16 Nwing, float *p_in,
                    float *p_out, UINT32 ui_remainder,
                    UINT32 ui_output_rate, INT16 Inc, int i_nb_channels );
void FilterFloatUD( float Imp[], float ImpD[], UINT16 Nwing, float *p_in,
                    float *p_out, UINT32 ui_remainder,
                    UINT32 ui_output_rate, UINT32 ui_input_rate,
                    INT16 Inc, int i_nb_channels );

/*****************************************************************************
 * FindFilter: find an audio filter for a specific transformation
 *****************************************************************************/
static aout_filter_t * FindFilter( CAudioOutput * p_aout,
                             const audio_sample_format_t * p_input_format,
                             const audio_sample_format_t * p_output_format )
{
	int ret = -1;

    aout_filter_t * p_filter = (aout_filter_t *)malloc( sizeof(aout_filter_t) );

    if ( p_filter == NULL ) return NULL;

	p_filter->p_sys = NULL;
    memcpy( &p_filter->input, p_input_format, sizeof(audio_sample_format_t) );
    memcpy( &p_filter->output, p_output_format,
            sizeof(audio_sample_format_t) );


	ret = CreateFloat32ToS16Filter(p_filter);
	if (ret == 0) goto found;
	ret = CreateS16ToFloat32Filter(p_filter);
	if (ret == 0) goto found;
	ret = CreateTrivialChannelMixer(p_filter);
	if (ret == 0) goto found;
	ret = CreateBandlimitedResampler(p_filter);
	if (ret == 0) goto found;

	if (ret) {
		free(p_filter);
		return NULL;
	}

found:
    p_filter->b_continuity = false;

    return p_filter;
}

/*****************************************************************************
 * SplitConversion: split a conversion in two parts
 *****************************************************************************
 * Returns the number of conversions required by the first part - 0 if only
 * one conversion was asked.
 * Beware : p_output_format can be modified during this function if the
 * developer passed SplitConversion( toto, titi, titi, ... ). That is legal.
 * SplitConversion( toto, titi, toto, ... ) isn't.
 *****************************************************************************/
static int SplitConversion( const audio_sample_format_t * p_input_format,
                            const audio_sample_format_t * p_output_format,
                            audio_sample_format_t * p_middle_format )
{
    bool b_format =
             (p_input_format->i_format != p_output_format->i_format);
    bool b_rate = (p_input_format->i_rate != p_output_format->i_rate);
    bool b_channels =
        (p_input_format->i_physical_channels
          != p_output_format->i_physical_channels)
     || (p_input_format->i_original_channels
          != p_output_format->i_original_channels);
    int i_nb_conversions = b_format + b_rate + b_channels;

    if ( i_nb_conversions <= 1 ) return 0;

    memcpy( p_middle_format, p_output_format, sizeof(audio_sample_format_t) );

    if ( i_nb_conversions == 2 )
    {
        if ( !b_format || !b_channels )
        {
            p_middle_format->i_rate = p_input_format->i_rate;
            aout_FormatPrepare( p_middle_format );
            return 1;
        }

        /* !b_rate */
        p_middle_format->i_physical_channels
             = p_input_format->i_physical_channels;
        p_middle_format->i_original_channels
             = p_input_format->i_original_channels;
        aout_FormatPrepare( p_middle_format );
        return 1;
    }

    /* i_nb_conversion == 3 */
    p_middle_format->i_rate = p_input_format->i_rate;
    aout_FormatPrepare( p_middle_format );
    return 2;
}

static void ReleaseFilter( aout_filter_t * p_filter )
{
    //vlc_object_destroy( p_filter );
}

/*****************************************************************************
 * aout_FiltersCreatePipeline: create a filters pipeline to transform a sample
 *                             format to another
 *****************************************************************************
 * pi_nb_filters must be initialized before calling this function
 *****************************************************************************/
int aout_FiltersCreatePipeline( CAudioOutput * p_aout,
                                aout_filter_t ** pp_filters_start,
                                int * pi_nb_filters,
                                const audio_sample_format_t * p_input_format,
                                const audio_sample_format_t * p_output_format )
{
    aout_filter_t** pp_filters = pp_filters_start + *pi_nb_filters;
    audio_sample_format_t temp_format;
    int i_nb_conversions;

    if ( AOUT_FMTS_IDENTICAL( p_input_format, p_output_format ) )
    {
        _RPT0(_CRT_WARN, "no need for any filter\n" );
        return 0;
    }

    aout_FormatsPrint( p_aout, _T("filter(s)"), p_input_format, p_output_format );

    if( *pi_nb_filters + 1 > AOUT_MAX_FILTERS )
    {
        _RPT1(_CRT_WARN, "max filter reached (%d)\n", AOUT_MAX_FILTERS );
        return -1;
    }

    /* Try to find a filter to do the whole conversion. */
    pp_filters[0] = FindFilter( p_aout, p_input_format, p_output_format );
    if ( pp_filters[0] != NULL )
    {
        _RPT0(_CRT_WARN, "found a filter for the whole conversion\n" );
        ++*pi_nb_filters;
        return 0;
    }

    /* We'll have to split the conversion. We always do the downmixing
     * before the resampling, because the audio decoder can probably do it
     * for us. */
    i_nb_conversions = SplitConversion( p_input_format,
                                        p_output_format, &temp_format );
    if ( !i_nb_conversions )
    {
        /* There was only one conversion to do, and we already failed. */
        _RPT0(_CRT_WARN, "couldn't find a filter for the conversion\n" );
        return -1;
    }

    pp_filters[0] = FindFilter( p_aout, p_input_format, &temp_format );
    if ( pp_filters[0] == NULL && i_nb_conversions == 2 )
    {
        /* Try with only one conversion. */
        SplitConversion( p_input_format, &temp_format, &temp_format );
        pp_filters[0] = FindFilter( p_aout, p_input_format, &temp_format );
    }
    if ( pp_filters[0] == NULL )
    {
        _RPT0(_CRT_WARN,
              "couldn't find a filter for the first part of the conversion\n" );
        return -1;
    }

    /* We have the first stage of the conversion. Find a filter for
     * the rest. */
    if( *pi_nb_filters + 2 > AOUT_MAX_FILTERS )
    {
        ReleaseFilter( pp_filters[0] );
        _RPT1(_CRT_WARN, "max filter reached (%d)\n", AOUT_MAX_FILTERS );
        return -1;
    }
    pp_filters[1] = FindFilter( p_aout, &pp_filters[0]->output,
                                p_output_format );
    if ( pp_filters[1] == NULL )
    {
        /* Try to split the conversion. */
        i_nb_conversions = SplitConversion( &pp_filters[0]->output,
                                           p_output_format, &temp_format );
        if ( !i_nb_conversions )
        {
            ReleaseFilter( pp_filters[0] );
            _RPT0(_CRT_WARN,
              "couldn't find a filter for the second part of the conversion\n" );
            return -1;
        }
        if( *pi_nb_filters + 3 > AOUT_MAX_FILTERS )
        {
            ReleaseFilter( pp_filters[0] );
            _RPT1(_CRT_WARN, "max filter reached (%d)\n", AOUT_MAX_FILTERS );
            return -1;
        }
        pp_filters[1] = FindFilter( p_aout, &pp_filters[0]->output,
                                    &temp_format );
        pp_filters[2] = FindFilter( p_aout, &temp_format,
                                    p_output_format );

        if ( pp_filters[1] == NULL || pp_filters[2] == NULL )
        {
            ReleaseFilter( pp_filters[0] );
            if ( pp_filters[1] != NULL )
            {
                ReleaseFilter( pp_filters[1] );
            }
            if ( pp_filters[2] != NULL )
            {
                ReleaseFilter( pp_filters[2] );
            }
            _RPT0(_CRT_WARN,
               "couldn't find filters for the second part of the conversion\n" );
            return -1;
        }
        *pi_nb_filters += 3;
        _RPT0(_CRT_WARN, "found 3 filters for the whole conversion\n" );
    }
    else
    {
        *pi_nb_filters += 2;
        _RPT0(_CRT_WARN, "found 2 filters for the whole conversion\n" );
    }

    return 0;
}

/*****************************************************************************
* aout_FiltersDestroyPipeline: deallocate a filters pipeline
*****************************************************************************/
void aout_FiltersDestroyPipeline( CAudioOutput * p_aout,
																 aout_filter_t ** pp_filters,
																 int i_nb_filters )
{
	int i;

	for ( i = 0; i < i_nb_filters; i++ )
	{
		if (pp_filters[i]) {
			if ( pp_filters[i]->p_sys ) {
				free(pp_filters[i]->p_sys->p_buf);
				free(pp_filters[i]->p_sys);
			}
			free(pp_filters[i]);
		}
	}
}

/*****************************************************************************
 * aout_FiltersHintBuffers: fill in aout_alloc_t structures to optimize
 *                          buffer allocations
 *****************************************************************************/
void aout_FiltersHintBuffers( CAudioOutput * p_aout,
                              aout_filter_t ** pp_filters,
                              int i_nb_filters, aout_alloc_t * p_first_alloc )
{
    int i;

    (void)p_aout; /* unused */

    for ( i = i_nb_filters - 1; i >= 0; i-- )
    {
        aout_filter_t * p_filter = pp_filters[i];

        int i_output_size = p_filter->output.i_bytes_per_frame
                             * p_filter->output.i_rate
                             / p_filter->output.i_frame_length;
        int i_input_size = p_filter->input.i_bytes_per_frame
                             * p_filter->input.i_rate
                             / p_filter->input.i_frame_length;

        p_first_alloc->i_bytes_per_sec = max( p_first_alloc->i_bytes_per_sec,
                                                i_output_size );

        if ( p_filter->b_in_place )
        {
            p_first_alloc->i_bytes_per_sec = max(
                                         p_first_alloc->i_bytes_per_sec,
                                         i_input_size );
            p_filter->output_alloc.i_alloc_type = AOUT_ALLOC_NONE;
        }
        else
        {
            /* We're gonna need a buffer allocation. */
            memcpy( &p_filter->output_alloc, p_first_alloc,
                    sizeof(aout_alloc_t) );
            p_first_alloc->i_alloc_type = AOUT_ALLOC_STACK;
            p_first_alloc->i_bytes_per_sec = i_input_size;
        }
    }
}

/*****************************************************************************
 * aout_FiltersPlay: play a buffer
 *****************************************************************************/
void aout_FiltersPlay( CAudioOutput * p_aout,
                       aout_filter_t ** pp_filters,
                       int i_nb_filters, aout_buffer_t ** pp_input_buffer )
{
    int i;

    for ( i = 0; i < i_nb_filters; i++ )
    {
        aout_filter_t * p_filter = pp_filters[i];
        aout_buffer_t * p_output_buffer;

        /* Resamplers can produce slightly more samples than (i_in_nb *
         * p_filter->output.i_rate / p_filter->input.i_rate) so we need
         * slightly bigger buffers. */
        aout_BufferAlloc( &p_filter->output_alloc,
            ((mtime_t)(*pp_input_buffer)->i_nb_samples + 2)
            * 1000000 / p_filter->input.i_rate,
            *pp_input_buffer, p_output_buffer );
        if ( p_output_buffer == NULL )
        {
            _RPT0(_CRT_WARN, "out of memory" );
            return;
        }
        /* Please note that p_output_buffer->i_nb_samples & i_nb_bytes
         * shall be set by the filter plug-in. */

        p_filter->pf_do_work( p_aout, p_filter, *pp_input_buffer,
                              p_output_buffer );

        if ( !p_filter->b_in_place )
        {
            aout_BufferFree( *pp_input_buffer );
            *pp_input_buffer = p_output_buffer;
        }
    }
}


//Audio filter for float32->s16 conversion
/*****************************************************************************
 * Create: allocate trivial mixer
 *****************************************************************************/
static int CreateFloat32ToS16Filter(aout_filter_t *p_filter)
{
    if ( p_filter->input.i_format != TME_FOURCC('f','l','3','2')
          || p_filter->output.i_format != AOUT_FMT_S16_NE )
    {
        return -1;
    }

    if ( !AOUT_FMTS_SIMILAR( &p_filter->input, &p_filter->output ) )
    {
        return -1;
    }

	p_filter->pf_do_work = DoFloat32ToS16;
    p_filter->b_in_place = true;

    return 0;
}

/*****************************************************************************
 * DoWork: convert a buffer
 *****************************************************************************/
static void DoFloat32ToS16( CAudioOutput * p_aout, aout_filter_t * p_filter,
                    aout_buffer_t * p_in_buf, aout_buffer_t * p_out_buf )
{
    int i;
    float * p_in = (float *)p_in_buf->p_buffer;
    INT16 * p_out = (INT16 *)p_out_buf->p_buffer;

    for ( i = p_in_buf->i_nb_samples
               * aout_FormatNbChannels( &p_filter->input ); i-- ; )
    {
#if 0
        /* Slow version. */
        if ( *p_in >= 1.0 ) *p_out = 32767;
        else if ( *p_in < -1.0 ) *p_out = -32768;
        else *p_out = *p_in * 32768.0;
#else
        /* This is walken's trick based on IEEE float format. */
        union { float f; INT32 i; } u;
        u.f = *p_in + 384.0f;
        if ( u.i > 0x43c07fff ) *p_out = 32767;
        else if ( u.i < 0x43bf8000 ) *p_out = -32768;
        else *p_out = u.i - 0x43c00000;
#endif
        p_in++; p_out++;
    }

    p_out_buf->i_nb_samples = p_in_buf->i_nb_samples;
    p_out_buf->i_nb_bytes = p_in_buf->i_nb_bytes / 2;
}

/*****************************************************************************
 * Create: allocate trivial mixer
 *****************************************************************************
 * This function allocates and initializes a Crop vout method.
 *****************************************************************************/
static int CreateS16ToFloat32Filter( aout_filter_t * p_filter )
{
    if ( ( p_filter->input.i_format != AOUT_FMT_S16_NE &&
           p_filter->input.i_format != AOUT_FMT_S24_NE )
          || p_filter->output.i_format != TME_FOURCC('f','l','3','2') )
    {
        return -1;
    }

    if ( !AOUT_FMTS_SIMILAR( &p_filter->input, &p_filter->output ) )
    {
        return -1;
    }

    if( p_filter->input.i_format == AOUT_FMT_S24_NE )
        p_filter->pf_do_work = DoS16toFloat32_24;
    else
        p_filter->pf_do_work = DoS16toFloat32;

    p_filter->b_in_place = true;

    return 0;
}

/*****************************************************************************
 * DoWork: convert a buffer
 *****************************************************************************/
static void DoS16toFloat32( CAudioOutput * p_aout, aout_filter_t * p_filter,
                    aout_buffer_t * p_in_buf, aout_buffer_t * p_out_buf )
{
    int i = p_in_buf->i_nb_samples * aout_FormatNbChannels( &p_filter->input );

    /* We start from the end because b_in_place is true */
    INT16 * p_in = (INT16 *)p_in_buf->p_buffer + i - 1;
    float * p_out = (float *)p_out_buf->p_buffer + i - 1;

    while( i-- )
    {
#if 0
        /* Slow version */
        *p_out = (float)*p_in / 32768.0;
#else
        /* This is walken's trick based on IEEE float format. On my PIII
         * this takes 16 seconds to perform one billion conversions, instead
         * of 19 seconds for the above division. */
        union { float f; INT32 i; } u;
        u.i = (INT32)*p_in + 0x43c00000;
        *p_out = u.f - 384.0f;
#endif

        p_in--; p_out--;
    }

    p_out_buf->i_nb_samples = p_in_buf->i_nb_samples;
    p_out_buf->i_nb_bytes = p_in_buf->i_nb_bytes * 2;
}

static void DoS16toFloat32_24( CAudioOutput * p_aout, aout_filter_t * p_filter,
                      aout_buffer_t * p_in_buf, aout_buffer_t * p_out_buf )
{
    int i = p_in_buf->i_nb_samples * aout_FormatNbChannels( &p_filter->input );

    /* We start from the end because b_in_place is true */
    UINT8 * p_in = (UINT8 *)p_in_buf->p_buffer + (i - 1) * 3;
    float * p_out = (float *)p_out_buf->p_buffer + i - 1;

    while( i-- )
    {
#ifdef WORDS_BIGENDIAN
        *p_out = ((float)( (((INT32)*(INT16 *)(p_in)) << 8) + p_in[2]))
#else
        *p_out = ((float)( (((INT32)*(INT16 *)(p_in+1)) << 8) + p_in[0]))
#endif
            / 8388608.0f;

        p_in -= 3; p_out--;
    }

    p_out_buf->i_nb_samples = p_in_buf->i_nb_samples;
    p_out_buf->i_nb_bytes = p_in_buf->i_nb_bytes * 4 / 3;
}

/*****************************************************************************
 * Create: allocate trivial channel mixer
 *****************************************************************************/
static int CreateTrivialChannelMixer( aout_filter_t * p_filter )
{
    if ( (p_filter->input.i_physical_channels
           == p_filter->output.i_physical_channels
           && p_filter->input.i_original_channels
               == p_filter->output.i_original_channels)
          || p_filter->input.i_format != p_filter->output.i_format
          || p_filter->input.i_rate != p_filter->output.i_rate
          || (p_filter->input.i_format != TME_FOURCC('f','l','3','2')
               && p_filter->input.i_format != TME_FOURCC('f','i','3','2')) )
    {
        return -1;
    }

    p_filter->pf_do_work = DoTrivialChannelMixer;
    if ( aout_FormatNbChannels( &p_filter->input )
           > aout_FormatNbChannels( &p_filter->output ) )
    {
        /* Downmixing */
        p_filter->b_in_place = true;
    }
    else
    {
        /* Upmixing */
        p_filter->b_in_place = false;
    }

    return 0;
}

/*****************************************************************************
 * SparseCopy: trivially downmix or upmix a buffer
 *****************************************************************************/
static void SparseCopy( INT32 * p_dest, const INT32 * p_src, size_t i_len,
                        int i_output_stride, int i_input_stride )
{
    int i;
    for ( i = (int)i_len; i--; )
    {
        int j;
        for ( j = 0; j < i_output_stride; j++ )
        {
            p_dest[j] = p_src[j % i_input_stride];
        }
        p_src += i_input_stride;
        p_dest += i_output_stride;
    }
}

/*****************************************************************************
 * DoWork: convert a buffer
 *****************************************************************************/
static void DoTrivialChannelMixer( CAudioOutput * p_aout, aout_filter_t * p_filter,
                    aout_buffer_t * p_in_buf, aout_buffer_t * p_out_buf )
{
    int i_input_nb = aout_FormatNbChannels( &p_filter->input );
    int i_output_nb = aout_FormatNbChannels( &p_filter->output );
    INT32 * p_dest = (INT32 *)p_out_buf->p_buffer;
    INT32 * p_src = (INT32 *)p_in_buf->p_buffer;

    p_out_buf->i_nb_samples = p_in_buf->i_nb_samples;
    p_out_buf->i_nb_bytes = p_in_buf->i_nb_bytes * i_output_nb / i_input_nb;

    if ( (p_filter->output.i_original_channels & AOUT_CHAN_PHYSMASK)
                != (p_filter->input.i_original_channels & AOUT_CHAN_PHYSMASK)
           && (p_filter->input.i_original_channels & AOUT_CHAN_PHYSMASK)
                == (AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT) )
    {
        int i;
        /* This is a bit special. */
        if ( !(p_filter->output.i_original_channels & AOUT_CHAN_LEFT) )
        {
            p_src++;
        }
        if ( p_filter->output.i_physical_channels == AOUT_CHAN_CENTER )
        {
            /* Mono mode */
            for ( i = p_in_buf->i_nb_samples; i--; )
            {
                *p_dest = *p_src;
                p_dest++;
                p_src += 2;
            }
        }
        else
        {
            /* Fake-stereo mode */
            for ( i = p_in_buf->i_nb_samples; i--; )
            {
                *p_dest = *p_src;
                p_dest++;
                *p_dest = *p_src;
                p_dest++;
                p_src += 2;
            }
        }
    }
    else if ( p_filter->output.i_original_channels
                                    & AOUT_CHAN_REVERSESTEREO )
    {
        /* Reverse-stereo mode */
        int i;
        for ( i = p_in_buf->i_nb_samples; i--; )
        {
            *p_dest = p_src[1];
            p_dest++;
            *p_dest = p_src[0];
            p_dest++;
            p_src += 2;
        }
    }
    else
    {
        SparseCopy( p_dest, p_src, p_in_buf->i_nb_samples, i_output_nb,
                    i_input_nb );
    }
}

/*****************************************************************************
 * Create: allocate linear resampler
 *****************************************************************************/
static int CreateBandlimitedResampler( aout_filter_t * p_filter )
{
    double d_factor;
    int i_filter_wing;

    if ( p_filter->input.i_rate == p_filter->output.i_rate
          || p_filter->input.i_format != p_filter->output.i_format
          || p_filter->input.i_physical_channels
              != p_filter->output.i_physical_channels
          || p_filter->input.i_original_channels
              != p_filter->output.i_original_channels
          || p_filter->input.i_format != TME_FOURCC('f','l','3','2') )
    {
        return EGENERIC;
    }

    /* Allocate the memory needed to store the module's structure */
    p_filter->p_sys = (struct aout_filter_sys_t *)malloc( sizeof(struct aout_filter_sys_t) );
    if( p_filter->p_sys == NULL )
    {
        _RPT0(_CRT_WARN, "out of memory\n" );
        return ENOMEM;
    }

    /* Calculate worst case for the length of the filter wing */
    d_factor = (double)p_filter->output.i_rate
                        / p_filter->input.i_rate;
    i_filter_wing = (int)(((SMALL_FILTER_NMULT + 1)/2.0)
                      * max(1.0, 1.0/d_factor) + 10);
    p_filter->p_sys->i_buf_size = aout_FormatNbChannels( &p_filter->input ) *
        sizeof(INT32) * 2 * i_filter_wing;

    /* Allocate enough memory to buffer previous samples */
    p_filter->p_sys->p_buf = (INT32 *)malloc( p_filter->p_sys->i_buf_size );
    if( p_filter->p_sys->p_buf == NULL )
    {
        _RPT0(_CRT_WARN, "out of memory\n" );
        return ENOMEM;
    }

    p_filter->p_sys->i_old_wing = 0;
    p_filter->pf_do_work = DoBandlimitedResampler;

    /* We don't want a new buffer to be created because we're not sure we'll
     * actually need to resample anything. */
    p_filter->b_in_place = true;

	return SUCCESS;
}

/*****************************************************************************
 * Close: free our resources
 *****************************************************************************/
static void CloseBandlimitedResampler( aout_filter_t * p_filter )
{
    free( p_filter->p_sys->p_buf );
    free( p_filter->p_sys );
}

/*****************************************************************************
 * DoWork: convert a buffer
 *****************************************************************************/
static void DoBandlimitedResampler( CAudioOutput * p_aout, aout_filter_t * p_filter,
                    aout_buffer_t * p_in_buf, aout_buffer_t * p_out_buf )
{
    float *p_in, *p_in_orig, *p_out = (float *)p_out_buf->p_buffer;

    int i_nb_channels = aout_FormatNbChannels( &p_filter->input );
    int i_in_nb = p_in_buf->i_nb_samples;
    int i_in, i_out = 0;
    double d_factor, d_scale_factor, d_old_scale_factor;
    int i_filter_wing;

    /* Check if we really need to run the resampler */
    if( p_aout->m_mixer.mixer.i_rate == p_filter->input.i_rate )
    {
        if( //p_filter->b_continuity && /* What difference does it make ? :) */
            p_filter->p_sys->i_old_wing &&
            p_in_buf->i_size >=
              p_in_buf->i_nb_bytes + p_filter->p_sys->i_old_wing *
              p_filter->input.i_bytes_per_frame )
        {
            /* output the whole thing with the samples from last time */
            memmove( ((float *)(p_in_buf->p_buffer)) +
                     i_nb_channels * p_filter->p_sys->i_old_wing,
                     p_in_buf->p_buffer, p_in_buf->i_nb_bytes );
            memcpy( p_in_buf->p_buffer, p_filter->p_sys->p_buf +
                    i_nb_channels * p_filter->p_sys->i_old_wing,
                    p_filter->p_sys->i_old_wing *
                    p_filter->input.i_bytes_per_frame );

            p_out_buf->i_nb_samples = p_in_buf->i_nb_samples +
                p_filter->p_sys->i_old_wing;

            p_out_buf->start_date = aout_DateGet( &p_filter->p_sys->end_date );
            p_out_buf->end_date =
                aout_DateIncrement( &p_filter->p_sys->end_date,
                                    p_out_buf->i_nb_samples );

            p_out_buf->i_nb_bytes = p_out_buf->i_nb_samples *
                p_filter->input.i_bytes_per_frame;
        }
        p_filter->b_continuity = false;
        p_filter->p_sys->i_old_wing = 0;
        return;
    }

    if( !p_filter->b_continuity )
    {
        /* Continuity in sound samples has been broken, we'd better reset
         * everything. */
        p_filter->b_continuity = true;
        p_filter->p_sys->i_remainder = 0;
        aout_DateInit( &p_filter->p_sys->end_date, p_filter->output.i_rate );
        aout_DateSet( &p_filter->p_sys->end_date, p_in_buf->start_date );
        p_filter->p_sys->i_old_rate   = p_filter->input.i_rate;
        p_filter->p_sys->d_old_factor = 1;
        p_filter->p_sys->i_old_wing   = 0;
    }

#if 0
    _RPT0(_CRT_WARN, "old rate: %i, old factor: %f, old wing: %i, i_in: %i",
             p_filter->p_sys->i_old_rate, p_filter->p_sys->d_old_factor,
             p_filter->p_sys->i_old_wing, i_in_nb );
#endif

    /* Prepare the source buffer */
    i_in_nb += (p_filter->p_sys->i_old_wing * 2);
#ifdef HAVE_ALLOCA
    p_in = p_in_orig = (float *)alloca( i_in_nb *
                                        p_filter->input.i_bytes_per_frame );
#else
    p_in = p_in_orig = (float *)malloc( i_in_nb *
                                        p_filter->input.i_bytes_per_frame );
#endif
    if( p_in == NULL )
    {
        return;
    }

    /* Copy all our samples in p_in */
    if( p_filter->p_sys->i_old_wing )
    {
        memcpy( p_in, p_filter->p_sys->p_buf,
                                  p_filter->p_sys->i_old_wing * 2 *
                                  p_filter->input.i_bytes_per_frame );
    }
    memcpy( p_in + p_filter->p_sys->i_old_wing * 2 *
                              i_nb_channels, p_in_buf->p_buffer,
                              p_in_buf->i_nb_samples *
                              p_filter->input.i_bytes_per_frame );

    /* Make sure the output buffer is reset */
    memset( p_out, 0, p_out_buf->i_size );

    /* Calculate the new length of the filter wing */
    d_factor = (double)p_aout->m_mixer.mixer.i_rate / p_filter->input.i_rate;
    i_filter_wing = (int)(((SMALL_FILTER_NMULT+1)/2.0) * max(1.0,1.0/d_factor) + 1);

    /* Account for increased filter gain when using factors less than 1 */
    d_old_scale_factor = SMALL_FILTER_SCALE *
        p_filter->p_sys->d_old_factor + 0.5;
    d_scale_factor = SMALL_FILTER_SCALE * d_factor + 0.5;

    /* Apply the old rate until we have enough samples for the new one */
    i_in = p_filter->p_sys->i_old_wing;
    p_in += p_filter->p_sys->i_old_wing * i_nb_channels;
    for( ; i_in < i_filter_wing &&
           (i_in + p_filter->p_sys->i_old_wing) < i_in_nb; i_in++ )
    {
        if( p_filter->p_sys->d_old_factor == 1 )
        {
            /* Just copy the samples */
            memcpy( p_out, p_in, 
                    p_filter->input.i_bytes_per_frame );          
            p_in += i_nb_channels;
            p_out += i_nb_channels;
            i_out++;
            continue;
        }

        while( p_filter->p_sys->i_remainder < p_filter->output.i_rate )
        {

            if( p_filter->p_sys->d_old_factor >= 1 )
            {
                /* FilterFloatUP() is faster if we can use it */

                /* Perform left-wing inner product */
                FilterFloatUP( SMALL_FILTER_FLOAT_IMP, SMALL_FILTER_FLOAT_IMPD,
                               SMALL_FILTER_NWING, p_in, p_out,
                               p_filter->p_sys->i_remainder,
                               p_filter->output.i_rate,
                               -1, i_nb_channels );
                /* Perform right-wing inner product */
                FilterFloatUP( SMALL_FILTER_FLOAT_IMP, SMALL_FILTER_FLOAT_IMPD,
                               SMALL_FILTER_NWING, p_in + i_nb_channels, p_out,
                               p_filter->output.i_rate -
                               p_filter->p_sys->i_remainder,
                               p_filter->output.i_rate,
                               1, i_nb_channels );

#if 0
                /* Normalize for unity filter gain */
                for( i = 0; i < i_nb_channels; i++ )
                {
                    *(p_out+i) *= d_old_scale_factor;
                }
#endif

                /* Sanity check */
                if( p_out_buf->i_size/p_filter->input.i_bytes_per_frame
                    <= (unsigned int)i_out+1 )
                {
                    p_out += i_nb_channels;
                    i_out++;
                    p_filter->p_sys->i_remainder += p_filter->input.i_rate;
                    break;
                }
            }
            else
            {
                /* Perform left-wing inner product */
                FilterFloatUD( SMALL_FILTER_FLOAT_IMP, SMALL_FILTER_FLOAT_IMPD,
                               SMALL_FILTER_NWING, p_in, p_out,
                               p_filter->p_sys->i_remainder,
                               p_filter->output.i_rate, p_filter->input.i_rate,
                               -1, i_nb_channels );
                /* Perform right-wing inner product */
                FilterFloatUD( SMALL_FILTER_FLOAT_IMP, SMALL_FILTER_FLOAT_IMPD,
                               SMALL_FILTER_NWING, p_in + i_nb_channels, p_out,
                               p_filter->output.i_rate -
                               p_filter->p_sys->i_remainder,
                               p_filter->output.i_rate, p_filter->input.i_rate,
                               1, i_nb_channels );
            }

            p_out += i_nb_channels;
            i_out++;

            p_filter->p_sys->i_remainder += p_filter->input.i_rate;
        }

        p_in += i_nb_channels;
        p_filter->p_sys->i_remainder -= p_filter->output.i_rate;
    }

    /* Apply the new rate for the rest of the samples */
    if( i_in < i_in_nb - i_filter_wing )
    {
        p_filter->p_sys->i_old_rate   = p_filter->input.i_rate;
        p_filter->p_sys->d_old_factor = d_factor;
        p_filter->p_sys->i_old_wing   = i_filter_wing;
    }
    for( ; i_in < i_in_nb - i_filter_wing; i_in++ )
    {
        while( p_filter->p_sys->i_remainder < p_filter->output.i_rate )
        {

            if( d_factor >= 1 )
            {
                /* FilterFloatUP() is faster if we can use it */

                /* Perform left-wing inner product */
                FilterFloatUP( SMALL_FILTER_FLOAT_IMP, SMALL_FILTER_FLOAT_IMPD,
                               SMALL_FILTER_NWING, p_in, p_out,
                               p_filter->p_sys->i_remainder,
                               p_filter->output.i_rate,
                               -1, i_nb_channels );

                /* Perform right-wing inner product */
                FilterFloatUP( SMALL_FILTER_FLOAT_IMP, SMALL_FILTER_FLOAT_IMPD,
                               SMALL_FILTER_NWING, p_in + i_nb_channels, p_out,
                               p_filter->output.i_rate -
                               p_filter->p_sys->i_remainder,
                               p_filter->output.i_rate,
                               1, i_nb_channels );

#if 0
                /* Normalize for unity filter gain */
                for( i = 0; i < i_nb_channels; i++ )
                {
                    *(p_out+i) *= d_old_scale_factor;
                }
#endif
                /* Sanity check */
                if( p_out_buf->i_size/p_filter->input.i_bytes_per_frame
                    <= (unsigned int)i_out+1 )
                {
                    p_out += i_nb_channels;
                    i_out++;
                    p_filter->p_sys->i_remainder += p_filter->input.i_rate;
                    break;
                }
            }
            else
            {
                /* Perform left-wing inner product */
                FilterFloatUD( SMALL_FILTER_FLOAT_IMP, SMALL_FILTER_FLOAT_IMPD,
                               SMALL_FILTER_NWING, p_in, p_out,
                               p_filter->p_sys->i_remainder,
                               p_filter->output.i_rate, p_filter->input.i_rate,
                               -1, i_nb_channels );
                /* Perform right-wing inner product */
                FilterFloatUD( SMALL_FILTER_FLOAT_IMP, SMALL_FILTER_FLOAT_IMPD,
                               SMALL_FILTER_NWING, p_in + i_nb_channels, p_out,
                               p_filter->output.i_rate -
                               p_filter->p_sys->i_remainder,
                               p_filter->output.i_rate, p_filter->input.i_rate,
                               1, i_nb_channels );
            }

            p_out += i_nb_channels;
            i_out++;

            p_filter->p_sys->i_remainder += p_filter->input.i_rate;
        }

        p_in += i_nb_channels;
        p_filter->p_sys->i_remainder -= p_filter->output.i_rate;
    }

    /* Buffer i_filter_wing * 2 samples for next time */
    if( p_filter->p_sys->i_old_wing )
    {
        memcpy( p_filter->p_sys->p_buf,
                p_in_orig + (i_in_nb - 2 * p_filter->p_sys->i_old_wing) *
                i_nb_channels, (2 * p_filter->p_sys->i_old_wing) *
                p_filter->input.i_bytes_per_frame );
    }

#if 0
    _RPT0(_CRT_WARN, "p_out size: %i, nb bytes out: %i", p_out_buf->i_size,
             i_out * p_filter->input.i_bytes_per_frame );
#endif

    /* Free the temp buffer */
#ifndef HAVE_ALLOCA
    free( p_in_orig );
#endif

    /* Finalize aout buffer */
    p_out_buf->i_nb_samples = i_out;
    p_out_buf->start_date = aout_DateGet( &p_filter->p_sys->end_date );
    p_out_buf->end_date = aout_DateIncrement( &p_filter->p_sys->end_date,
                                              p_out_buf->i_nb_samples );

    p_out_buf->i_nb_bytes = p_out_buf->i_nb_samples *
        i_nb_channels * sizeof(INT32);

}

void FilterFloatUP( float Imp[], float ImpD[], UINT16 Nwing, float *p_in,
                    float *p_out, UINT32 ui_remainder,
                    UINT32 ui_output_rate, INT16 Inc, int i_nb_channels )
{
    float *Hp, *Hdp, *End;
    float t, temp;
    UINT32 ui_linear_remainder;
    int i;

    Hp = &Imp[(ui_remainder<<Nhc)/ui_output_rate];
    Hdp = &ImpD[(ui_remainder<<Nhc)/ui_output_rate];

    End = &Imp[Nwing];

    ui_linear_remainder = (ui_remainder<<Nhc) -
                            (ui_remainder<<Nhc)/ui_output_rate*ui_output_rate;

    if (Inc == 1)               /* If doing right wing...              */
    {                           /* ...drop extra coeff, so when Ph is  */
        End--;                  /*    0.5, we don't do too many mult's */
        if (ui_remainder == 0)  /* If the phase is zero...           */
        {                       /* ...then we've already skipped the */
            Hp += Npc;          /*    first sample, so we must also  */
            Hdp += Npc;         /*    skip ahead in Imp[] and ImpD[] */
        }
    }

    while (Hp < End) {
        t = *Hp;                /* Get filter coeff */
                                /* t is now interp'd filter coeff */
        t += *Hdp * ui_linear_remainder / ui_output_rate / Npc;
        for( i = 0; i < i_nb_channels; i++ )
        {
            temp = t;
            temp *= *(p_in+i);  /* Mult coeff by input sample */
            *(p_out+i) += temp; /* The filter output */
        }
        Hdp += Npc;             /* Filter coeff differences step */
        Hp += Npc;              /* Filter coeff step */
        p_in += (Inc * i_nb_channels); /* Input signal step */
    }
}

void FilterFloatUD( float Imp[], float ImpD[], UINT16 Nwing, float *p_in,
                    float *p_out, UINT32 ui_remainder,
                    UINT32 ui_output_rate, UINT32 ui_input_rate,
                    INT16 Inc, int i_nb_channels )
{
    float *Hp, *Hdp, *End;
    float t, temp;
    UINT32 ui_linear_remainder;
    int i, ui_counter = 0;

    Hp = Imp + (ui_remainder<<Nhc) / ui_input_rate;
    Hdp = ImpD  + (ui_remainder<<Nhc) / ui_input_rate;

    End = &Imp[Nwing];

    if (Inc == 1)               /* If doing right wing...              */
    {                           /* ...drop extra coeff, so when Ph is  */
        End--;                  /*    0.5, we don't do too many mult's */
        if (ui_remainder == 0)  /* If the phase is zero...           */
        {                       /* ...then we've already skipped the */
            Hp = Imp +          /* first sample, so we must also  */
                  (ui_output_rate << Nhc) / ui_input_rate;
            Hdp = ImpD +        /* skip ahead in Imp[] and ImpD[] */
                  (ui_output_rate << Nhc) / ui_input_rate;
            ui_counter++;
        }
    }

    while (Hp < End) {
        t = *Hp;                /* Get filter coeff */
                                /* t is now interp'd filter coeff */
        ui_linear_remainder =
          ((ui_output_rate * ui_counter + ui_remainder)<< Nhc) -
          ((ui_output_rate * ui_counter + ui_remainder)<< Nhc) /
          ui_input_rate * ui_input_rate;
        t += *Hdp * ui_linear_remainder / ui_input_rate / Npc;
        for( i = 0; i < i_nb_channels; i++ )
        {
            temp = t;
            temp *= *(p_in+i);  /* Mult coeff by input sample */
            *(p_out+i) += temp; /* The filter output */
        }

        ui_counter++;

        /* Filter coeff step */
        Hp = Imp + ((ui_output_rate * ui_counter + ui_remainder)<< Nhc)
                    / ui_input_rate;
        /* Filter coeff differences step */
        Hdp = ImpD + ((ui_output_rate * ui_counter + ui_remainder)<< Nhc)
                     / ui_input_rate;

        p_in += (Inc * i_nb_channels); /* Input signal step */
    }
}
